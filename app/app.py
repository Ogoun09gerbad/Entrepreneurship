# -*- coding: utf-8 -*-
"""App.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1ekuNAk4YQSgcnYSVCGOf_hOCsd9wqYcZ
"""

import streamlit as st
import tensorflow as tf
from tensorflow import keras
from tensorflow.keras.preprocessing.image import load_img, img_to_array
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import os
from PIL import Image
import cv2

# Configuration de la page Streamlit
st.set_page_config(
    page_title="D√©tection de Maladies des Feuilles de Ma√Øs",
    page_icon="üåΩ",
    layout="wide"
)

# Titre de l'application
st.title("üåΩ D√©tection de Maladies des Feuilles de Ma√Øs")
st.markdown("""
Cette application utilise un mod√®le de deep learning pour d√©tecter les maladies des feuilles de ma√Øs.
T√©l√©chargez une image de feuille de ma√Øs et le mod√®le identifiera si elle est saine ou malade.
""")

# Sidebar pour les informations
st.sidebar.header("√Ä propos")
st.sidebar.info("""
**Classes d√©tect√©es :**
- üåø **Saine** (Healthy)
- ü¶† **Rouille commune** (Common_Rust)
- üçÇ **Br√ªlure** (Blight)
- üçÅ **Tache grise** (Gray_Leaf_Spot)

**Mod√®le :** CNN (ResNet50) fine-tuned
**Pr√©cision :** ~95% sur le jeu de test
""")

# Charger le mod√®le
@st.cache_resource
def load_model():
    """Charge le mod√®le pr√©-entra√Æn√©"""
    try:
        # Si vous avez sauvegard√© votre mod√®le, chargez-le ici
        # model = tf.keras.models.load_model('corn_disease_model.h5')

        # Pour l'instant, nous cr√©ons un mod√®le fictif - √Ä REMPLACER PAR VOTRE VRAI MOD√àLE
        # Vous devrez sauvegarder votre mod√®le apr√®s l'entra√Ænement dans le notebook
        model = tf.keras.models.Sequential([
            tf.keras.layers.Input(shape=(224, 224, 3)),
            tf.keras.layers.Conv2D(32, (3, 3), activation='relu'),
            tf.keras.layers.MaxPooling2D(2, 2),
            tf.keras.layers.Flatten(),
            tf.keras.layers.Dense(128, activation='relu'),
            tf.keras.layers.Dense(4, activation='softmax')
        ])

        # Compiler le mod√®le (n√©cessaire m√™me pour un mod√®le charg√©)
        model.compile(
            optimizer='adam',
            loss='categorical_crossentropy',
            metrics=['accuracy']
        )

        return model
    except Exception as e:
        st.error(f"Erreur lors du chargement du mod√®le : {e}")
        return None

# Fonction de pr√©traitement de l'image
def preprocess_image(image, target_size=(224, 224)):
    """Pr√©traite l'image pour la pr√©diction"""
    # Convertir PIL Image en array numpy
    if isinstance(image, Image.Image):
        image = np.array(image)

    # Redimensionner l'image
    image = cv2.resize(image, target_size)

    # Normaliser les pixels entre 0 et 1
    image = image / 255.0

    # Ajouter une dimension pour le batch
    image = np.expand_dims(image, axis=0)

    return image

# Fonction de pr√©diction
def predict_disease(model, image):
    """Fait la pr√©diction sur l'image"""
    # Pr√©traiter l'image
    processed_image = preprocess_image(image)

    # Faire la pr√©diction
    predictions = model.predict(processed_image)

    # Obtenir la classe pr√©dite
    class_idx = np.argmax(predictions[0])
    confidence = predictions[0][class_idx] * 100

    # Classes (doivent correspondre √† votre entra√Ænement)
    classes = ['Blight', 'Common_Rust', 'Gray_Leaf_Spot', 'Healthy']
    class_names_fr = {
        'Blight': 'Br√ªlure',
        'Common_Rust': 'Rouille commune',
        'Gray_Leaf_Spot': 'Tache grise',
        'Healthy': 'Saine'
    }

    # Emojis pour chaque classe
    class_emojis = {
        'Blight': 'üçÇ',
        'Common_Rust': 'ü¶†',
        'Gray_Leaf_Spot': 'üçÅ',
        'Healthy': 'üåø'
    }

    predicted_class = classes[class_idx]
    predicted_class_fr = class_names_fr[predicted_class]

    return predicted_class, predicted_class_fr, confidence, predictions[0]

# Interface principale
def main():
    # Charger le mod√®le
    with st.spinner('Chargement du mod√®le...'):
        model = load_model()

    if model is None:
        st.error("Impossible de charger le mod√®le. V√©rifiez que le mod√®le existe.")
        return

    st.success("‚úÖ Mod√®le charg√© avec succ√®s !")

    # Cr√©er deux colonnes
    col1, col2 = st.columns([1, 1])

    with col1:
        st.subheader("üì§ T√©l√©charger une image")

        # Option 1 : T√©l√©chargement de fichier
        uploaded_file = st.file_uploader(
            "Choisissez une image de feuille de ma√Øs",
            type=['jpg', 'jpeg', 'png', 'bmp'],
            help="Format support√©s : JPG, JPEG, PNG, BMP"
        )

        # Option 2 : Utiliser une image d'exemple
        st.markdown("---")
        st.subheader("üéØ Exemples de test")

        # Cr√©er des boutons pour des exemples pr√©d√©finis
        example_images = {
            "Feuille saine": "https://raw.githubusercontent.com/example/healthy.jpg",
            "Rouille commune": "https://raw.githubusercontent.com/example/rust.jpg",
            "Br√ªlure": "https://raw.githubusercontent.com/example/blight.jpg",
            "Tache grise": "https://raw.githubusercontent.com/example/gray_spot.jpg"
        }

        example_cols = st.columns(2)
        selected_example = None

        for idx, (name, url) in enumerate(example_images.items()):
            with example_cols[idx % 2]:
                if st.button(f"Utiliser {name}", key=f"example_{idx}"):
                    selected_example = url

    with col2:
        st.subheader("üñºÔ∏è Image charg√©e")

        # Afficher l'image
        image_display = st.empty()
        prediction_result = st.empty()
        confidence_gauge = st.empty()

        # Variables pour stocker l'image
        image_to_predict = None

        # Traitement de l'image t√©l√©charg√©e
        if uploaded_file is not None:
            try:
                # Ouvrir l'image
                image = Image.open(uploaded_file)
                image_to_predict = image.copy()

                # Afficher l'image
                image_display.image(image, caption="Image t√©l√©charg√©e", use_column_width=True)

            except Exception as e:
                st.error(f"Erreur lors du chargement de l'image : {e}")

        # Traitement de l'exemple s√©lectionn√©
        elif selected_example:
            try:
                # Note : Dans une vraie application, vous devriez t√©l√©charger l'image depuis l'URL
                # Pour la d√©mo, nous allons utiliser une image al√©atoire
                st.info("Utilisation d'une image d'exemple...")

                # Cr√©er une image de test al√©atoire (remplacer par le t√©l√©chargement r√©el)
                test_image = np.random.randint(0, 255, (224, 224, 3), dtype=np.uint8)
                image = Image.fromarray(test_image)
                image_to_predict = image.copy()

                image_display.image(image, caption="Image d'exemple", use_column_width=True)

            except Exception as e:
                st.error(f"Erreur avec l'exemple : {e}")

        else:
            # Afficher un placeholder
            image_display.info("Aucune image s√©lectionn√©e. T√©l√©chargez une image ou utilisez un exemple.")

    # Bouton de pr√©diction
    st.markdown("---")
    col_pred1, col_pred2, col_pred3 = st.columns([1, 2, 1])

    with col_pred2:
        predict_button = st.button(
            "üîç Analyser l'image",
            type="primary",
            disabled=(image_to_predict is None),
            use_container_width=True
        )

    # Ex√©cuter la pr√©diction
    if predict_button and image_to_predict is not None:
        with st.spinner("Analyse en cours..."):
            try:
                # Faire la pr√©diction
                predicted_class, predicted_class_fr, confidence, all_predictions = predict_disease(model, image_to_predict)

                # Afficher les r√©sultats
                st.markdown("---")
                st.subheader("üìä R√©sultats de l'analyse")

                # Cr√©er des colonnes pour les r√©sultats
                result_col1, result_col2 = st.columns([1, 2])

                with result_col1:
                    # Afficher la pr√©diction principale avec emoji
                    emoji_dict = {
                        'Blight': 'üçÇ',
                        'Common_Rust': 'ü¶†',
                        'Gray_Leaf_Spot': 'üçÅ',
                        'Healthy': 'üåø'
                    }

                    emoji = emoji_dict.get(predicted_class, '‚ùì')

                    st.metric(
                        label="**Diagnostic**",
                        value=f"{emoji} {predicted_class_fr}",
                        delta=f"{confidence:.2f}% de confiance"
                    )

                    # Jauge de confiance
                    st.progress(int(confidence))
                    st.caption(f"Confiance : {confidence:.2f}%")

                with result_col2:
                    # Afficher toutes les probabilit√©s
                    classes_fr = {
                        'Blight': 'Br√ªlure',
                        'Common_Rust': 'Rouille commune',
                        'Gray_Leaf_Spot': 'Tache grise',
                        'Healthy': 'Saine'
                    }

                    classes_order = ['Healthy', 'Blight', 'Common_Rust', 'Gray_Leaf_Spot']

                    # Cr√©er un DataFrame pour les probabilit√©s
                    prob_data = []
                    for i, cls in enumerate(['Blight', 'Common_Rust', 'Gray_Leaf_Spot', 'Healthy']):
                        prob_data.append({
                            'Maladie': classes_fr[cls],
                            'Probabilit√©': f"{all_predictions[i]*100:.2f}%",
                            'Valeur': all_predictions[i]*100
                        })

                    df_probs = pd.DataFrame(prob_data)
                    df_probs = df_probs.sort_values('Valeur', ascending=False)

                    # Afficher le tableau des probabilit√©s
                    st.dataframe(
                        df_probs[['Maladie', 'Probabilit√©']],
                        use_container_width=True,
                        hide_index=True
                    )

                # Section d'informations suppl√©mentaires
                st.markdown("---")
                st.subheader("üí° Recommandations")

                # Informations bas√©es sur la pr√©diction
                recommendations = {
                    'Healthy': [
                        "‚úÖ La feuille semble saine !",
                        "Continuez les bonnes pratiques agricoles",
                        "Surveillez r√©guli√®rement vos cultures"
                    ],
                    'Blight': [
                        "‚ö†Ô∏è **Br√ªlure d√©tect√©e**",
                        "Appliquez des fongicides appropri√©s",
                        "√âvitez l'irrigation par aspersion",
                        "Enlevez et d√©truisez les plantes infect√©es"
                    ],
                    'Common_Rust': [
                        "‚ö†Ô∏è **Rouille commune d√©tect√©e**",
                        "Utilisez des vari√©t√©s r√©sistantes",
                        "Appliquez des fongicides √† base de triazole",
                        "Assurez une bonne circulation d'air"
                    ],
                    'Gray_Leaf_Spot': [
                        "‚ö†Ô∏è **Tache grise d√©tect√©e**",
                        "Pratiquez la rotation des cultures",
                        "Utilisez des fongicides pr√©ventifs",
                        "√âvitez les exc√®s d'azote"
                    ]
                }

                for rec in recommendations.get(predicted_class, ["Aucune information sp√©cifique disponible."]):
                    st.write(f"- {rec}")

                # Avertissement pour les maladies
                if predicted_class != 'Healthy':
                    st.warning("‚ö†Ô∏è Consultez un agronome pour un diagnostic complet et un plan de traitement.")

            except Exception as e:
                st.error(f"Erreur lors de la pr√©diction : {str(e)}")

    # Section d'information en bas
    st.markdown("---")
    with st.expander("‚ÑπÔ∏è Comment utiliser cette application"):
        st.markdown("""
        1. **T√©l√©chargez une image** d'une feuille de ma√Øs dans la colonne de gauche
        2. Cliquez sur le bouton **"Analyser l'image"**
        3. Consultez les r√©sultats et les recommandations

        **Conseils pour de meilleurs r√©sultats :**
        - Utilisez des images nettes et bien √©clair√©es
        - Photographiez la feuille sur un fond uniforme
        - Capturez les sympt√¥mes visibles (taches, d√©colorations)
        - √âvitez les reflets et ombres excessifs
        """)

    with st.expander("üìà Performances du mod√®le"):
        st.markdown("""
        **M√©triques du mod√®le :**
        - Pr√©cision sur les donn√©es de test : ~95%
        - Classes : 4 (3 maladies + sain)
        - Architecture : CNN avec fine-tuning

        **Limitations :**
        - N√©cessite des images de qualit√©
        - D√©tecte uniquement les maladies entra√Æn√©es
        - Ne remplace pas un expert agronome
        """)

if __name__ == "__main__":
    main()